#!/usr/bin/env lua
local PKGLET_LIB = "/usr/lib/pkglet"
package.path = PKGLET_LIB .. "/?.lua;" .. package.path
local cli = require("src.cli")
local loader = require("src.loader")
local installer = require("src.installer")
local resolver = require("src.resolver")
local config = require("src.config")
local function main()
    config.init()
    local args = cli.parse(arg)
    if args.command == "i" or args.command == "install" then
        if args.unpin then
            config.unpin_package(args.package)
        end

        local package_name = args.package
        local conflict = require("src.conflict")
        local is_virtual = false
        for repo_name, repo_path in pairs(config.repos) do
            local cmd = "find " .. repo_path .. " -name manifest.lua"
            local handle = io.popen(cmd)
            if handle then
                for line in handle:lines() do
                    local manifest_path = line:match("^%s*(.-)%s*$")
                    if manifest_path and manifest_path ~= "" then
                        local ok, manifest = pcall(function()
                            local env = {}
                            setmetatable(env, {__index = _G})
                            local chunk, err = loadfile(manifest_path, "t", env)
                            if not chunk then return nil end
                            chunk()
                            return env.pkg
                        end)

                        if ok and manifest and manifest.name == package_name then
                            is_virtual = false
                            break
                        end
                        if ok and manifest and manifest.provides then
                            for _, provides in ipairs(manifest.provides) do
                                if provides == package_name then
                                    package_name = manifest.name
                                    is_virtual = true
                                    break
                                end
                            end
                        end
                    end
                end
                handle:close()
            end
        end

        local manifest = loader.load_manifest(package_name)

        if is_virtual then
            print("Resolving virtual package " .. args.package .. " to " .. package_name)
        end

        local pinned_version = config.is_pinned(package_name)
        if pinned_version then
            manifest.version = pinned_version
        elseif args.target_version then
            manifest.version = args.target_version
        end

        installer.install(manifest, args)

        if args.pin then
            config.pin_package(package_name, manifest.version)
        end

    elseif args.command == "u" or args.command == "uninstall" then
        local manifest = loader.load_manifest(args.package)
        
        if not args.noask then
            io.write("Uninstall " .. args.package .. "? \27[7m[Y/n]\27[0m ")
            local response = io.read()
            if response and response:lower():sub(1,1) == 'n' then
                print("Uninstall cancelled.")
                return
            end
        end
        
        installer.uninstall(manifest)
        config.unpin_package(args.package)

    elseif args.command == "U" or args.command == "upgrade" then
        if not args.package then
            installer.upgrade_all(args)
        else
            installer.upgrade(args.package, args)

            if args.pin then
                local latest_version = installer.get_installed_version(args.package)
                config.pin_package(args.package, latest_version)
            end
        end

    elseif args.command == "d" or args.command == "downgrade" then
        local target_version = args.target_version
        if not target_version then
            io.stderr:write("error: --to <version> required for downgrade\n")
            os.exit(1)
        end
        installer.downgrade(args.package, target_version, args)

        if args.pin then
            config.pin_package(args.package, target_version)
        end

    

    elseif args.command == "pin" then
        local package_name = args.package
        local target_version = args.target_version

        if target_version then
            config.pin_package(package_name, target_version)
            print("Pinned " .. package_name .. " to version " .. target_version)
        else
            local current_version = installer.get_installed_version(package_name)
            if current_version then
                config.pin_package(package_name, current_version)
                print("Pinned " .. package_name .. " to current version " .. current_version)
            else
                print("Package not installed: " .. package_name)
            end
        end

    elseif args.command == "unpin" then
        config.unpin_package(args.package)
        print("Unpinned " .. args.package)

    elseif args.command == "s" or args.command == "search" then
        local search = require("src.search")
        search.query(args.package)

    elseif args.command == "S" or args.command == "sync" then
        local sync = require("src.sync")
        sync.update_repos()

    

        

    elseif args.command == "I" or args.command == "info" then
        local manifest = loader.load_manifest(args.package)
        loader.print_info(manifest)

    

    elseif args.command == "c" or args.command == "clean" then
        os.execute("rm -rf " .. config.CACHE_PATH)

    else
        cli.print_help()
        os.exit(1)
    end
end

local status, err = pcall(main)
if not status then
    io.stderr:write("\27[1;32mpkglet\27[0m: \27[1;31merror\27[0m: " .. tostring(err) .. "\n")
    os.exit(1)
end
