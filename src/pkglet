#!/usr/bin/env lua
local function get_pkglet_lib()
    local f = io.popen("id -u 2>/dev/null")
    local is_root = f:read("*a"):match("^0$")
    f:close()
    if is_root then
        return "/usr/lib/pkglet"
    else
        return os.getenv("HOME") .. "/.local/lib/pkglet"
    end
end
local PKGLET_LIB = get_pkglet_lib()
package.path = PKGLET_LIB .. "/?.lua;" .. package.path
local cli = require("src.cli")
local loader = require("src.loader")
local installer = require("src.installer")
local resolver = require("src.resolver")
local config = require("src.config")
local function main()
    config.init()
    local args = cli.parse(arg)
    local binary_name = arg[0] or ""
    local is_bracket = binary_name:match(".*/]$") or binary_name == "]"
    if is_bracket then
        local has_b = false
        for _, a in ipairs(arg) do
            if a == "b" or a == "build" then
                has_b = true
                break
            end
        end
        if not has_b then
            table.insert(arg, 1, "install")
            args = cli.parse(arg)
        end
    end

    if args.command == "i" or args.command == "install" then
        if args.unpin then
            config.unpin_package(args.package)
        end

        local package_name = args.package
        local conflict = require("src.conflict")
        local providers = conflict.get_providers(package_name)
        if #providers > 0 then
            if #providers > 1 then
                if args.force then
                    package_name = providers[1]
                    print("Multiple providers for " .. args.package .. ", using " .. package_name .. " (--force)")
                else
                    print("Multiple providers available for " .. args.package .. ":")
                    for i, p in ipairs(providers) do
                        print("  " .. i .. ". " .. p)
                    end
                    io.write("Choose provider: ")
                    local choice = io.read()
                    local idx = tonumber(choice)
                    if idx and idx >= 1 and idx <= #providers then
                        package_name = providers[idx]
                    else
                        print("Invalid choice, using " .. providers[1])
                        package_name = providers[1]
                    end
                end
            else
                package_name = providers[1]
                print("Resolving virtual package " .. args.package .. " to " .. package_name)
            end
            if args.package_build_types and args.package_build_types[args.package] then
                args.package_build_types[package_name] = args.package_build_types[args.package]
            end
        end

        local manifest = loader.load_manifest(package_name)

        local pinned_version = config.is_pinned(package_name)
        if pinned_version then
            manifest.version = pinned_version
        elseif args.target_version then
            manifest.version = args.target_version
        end

        installer.install(manifest, args)

        if args.pin then
            config.pin_package(package_name, manifest.version)
        end

    elseif args.command == "u" or args.command == "uninstall" then
        local manifest = loader.load_manifest(args.package)

        if not args.noask then
            io.write("Uninstall " .. args.package .. "? \27[7m[Y/n]\27[0m ")
            local response = io.read()
            if response and response:lower():sub(1,1) == 'n' then
                print("Uninstall cancelled.")
                return
            end
        end

        installer.uninstall(manifest)
        config.unpin_package(args.package)

    elseif args.command == "U" or args.command == "upgrade" then
        if not args.package then
            installer.upgrade_all(args)
        else
            installer.upgrade(args.package, args)

            if args.pin then
                local latest_version = installer.get_installed_version(args.package)
                config.pin_package(args.package, latest_version)
            end
        end

    elseif args.command == "d" or args.command == "downgrade" then
        local target_version = args.target_version
        if not target_version then
            io.stderr:write("error: --to <version> required for downgrade\n")
            os.exit(1)
        end
        installer.downgrade(args.package, target_version, args)

        if args.pin then
            config.pin_package(args.package, target_version)
        end



    elseif args.command == "pin" then
        local package_name = args.package
        local target_version = args.target_version

        if target_version then
            config.pin_package(package_name, target_version)
            print("Pinned " .. package_name .. " to version " .. target_version)
        else
            local current_version = installer.get_installed_version(package_name)
            if current_version then
                config.pin_package(package_name, current_version)
                print("Pinned " .. package_name .. " to current version " .. current_version)
            else
                print("Package not installed: " .. package_name)
            end
        end

    elseif args.command == "unpin" then
        config.unpin_package(args.package)
        print("Unpinned " .. args.package)

    elseif args.command == "s" or args.command == "search" then
        local search = require("src.search")
        search.query(args.package)

    elseif args.command == "S" or args.command == "sync" then
        local sync = require("src.sync")
        sync.update_repos()





    elseif args.command == "I" or args.command == "info" then
        local manifest = loader.load_manifest(args.package)
        loader.print_info(manifest)


    elseif args.command == "b" or args.command == "build" then
        local temp_dir = os.tmpname()
        os.execute("rm -f " .. temp_dir)
        os.execute("mkdir -p " .. temp_dir)
        local bootstrap_dir = temp_dir .. "/root"
        os.execute("mkdir -p " .. bootstrap_dir)
        args.bootstrap_to = bootstrap_dir
        args.nodeps = true
        local conflict = require("src.conflict")
        local providers = conflict.get_providers(args.package)
        if #providers > 0 then
            args.package = providers[1]
        end
        local manifest = loader.load_manifest(args.package)
        installer.install(manifest, args)
        local pkg_name = args.package:gsub("%.", "-")
        local output_file = pkg_name .. "-" .. manifest.version .. ".tar"
        local compression = args.compression or "gzip"
        if compression == "gzip" then
            output_file = output_file .. ".gz"
        elseif compression == "bzip2" then
            output_file = output_file .. ".bz2"
        elseif compression == "xz" then
            output_file = output_file .. ".xz"
        elseif compression == "zstd" then
            output_file = output_file .. ".zst"
        end
        local tar_opts = "-cf"
        if compression == "gzip" then
            tar_opts = "-czf"
        elseif compression == "bzip2" then
            tar_opts = "-cjf"
        elseif compression == "xz" then
            tar_opts = "-cJf"
        elseif compression == "zstd" then
            tar_opts = "-cf --zstd"
        end
        print(":: stripping binaries")
        os.execute("cd " .. bootstrap_dir .. " && (strip **/* || true)")
        print(":: upx'ing binaries")
        os.execute("cd " .. bootstrap_dir .. " && (upx **/* || true)")
        print(":: compressing output")
        os.execute("cd " .. bootstrap_dir .. " && tar " .. tar_opts .. " " .. output_file .. " . 2>/dev/null")
        os.execute("mv " .. bootstrap_dir .. "/" .. output_file .. " .")
        os.execute("rm -rf " .. temp_dir)
        print(":: built: " .. output_file)

    elseif args.command == "c" or args.command == "clean" then
        os.execute("rm -rf " .. config.CACHE_PATH)

    else
        cli.print_help()
        os.exit(1)
    end
end

local status, err = pcall(main)
if not status then
    io.stderr:write("\27[1;32mpkglet\27[0m: \27[1;31merror\27[0m: " .. tostring(err) .. "\n")
    os.exit(1)
end
