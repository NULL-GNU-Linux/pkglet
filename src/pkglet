#!/usr/bin/env lua
local PKGLET_LIB = "/usr/lib/pkglet"
package.path = PKGLET_LIB .. "/?.lua;" .. package.path
local cli = require("src.cli")
local loader = require("src.loader")
local installer = require("src.installer")
local resolver = require("src.resolver")
local config = require("src.config")
local function main()
    config.init()
    local args = cli.parse(arg)
    if args.command == "i" or args.command == "install" then
        if args.unpin then
            config.unpin_package(args.package)
        end
        local manifest = loader.load_manifest(args.package)

        local pinned_version = config.is_pinned(args.package)
        if pinned_version then
            manifest.version = pinned_version
        elseif args.target_version then
            manifest.version = args.target_version
        end

        installer.install(manifest, args)

        if args.pin then
            config.pin_package(args.package, manifest.version)
        end

    elseif args.command == "u" or args.command == "uninstall" then
        local manifest = loader.load_manifest(args.package)
        installer.uninstall(manifest)
        config.unpin_package(args.package)

    elseif args.command == "U" or args.command == "upgrade" then
        installer.upgrade(args.package, args)

        if args.pin then
            local latest_version = installer.get_installed_version(args.package)
            config.pin_package(args.package, latest_version)
        end

    elseif args.command == "d" or args.command == "downgrade" then
        local target_version = args.target_version
        if not target_version then
            io.stderr:write("error: --to <version> required for downgrade\n")
            os.exit(1)
        end
        installer.downgrade(args.package, target_version, args)

        if args.pin then
            config.pin_package(args.package, target_version)
        end

    elseif args.command == "L" or args.command == "list-versions" then
        installer.list_versions(args.package)

    elseif args.command == "pin" then
        local package_name = args.package
        local target_version = args.target_version

        if target_version then
            config.pin_package(package_name, target_version)
            print("Pinned " .. package_name .. " to version " .. target_version)
        else
            local current_version = installer.get_installed_version(package_name)
            if current_version then
                config.pin_package(package_name, current_version)
                print("Pinned " .. package_name .. " to current version " .. current_version)
            else
                print("Package not installed: " .. package_name)
            end
        end

    elseif args.command == "unpin" then
        config.unpin_package(args.package)
        print("Unpinned " .. args.package)

    elseif args.command == "s" or args.command == "search" then
        local search = require("src.search")
        search.query(args.package)

    elseif args.command == "S" or args.command == "sync" then
        local sync = require("src.sync")
        sync.update_repos()

    elseif args.command == "M" or args.command == "generate-manifest" then
        local sync = require("src.sync")
        local repo_path = args.package or config.repos[config.get_repos_by_priority()[1]]
        if repo_path then
            sync.generate_repo_manifest(repo_path)
        else
            print("Error: Repository path required or no repositories configured")
        end

    elseif args.command == "G" or args.command == "gpg" then
        local gpg = require("src.gpg")
        local gpg_cmd = args.package or ""
        
        if gpg_cmd == "list-keys" then
            local keys = gpg.list_keys()
            if #keys == 0 then
                print("No GPG keys found")
            else
                print("GPG Keys:")
                for _, key in ipairs(keys) do
                    print("  " .. key.key_id .. " - " .. key.user_id .. " (" .. key.trust_name .. ")")
                end
            end
            
        elseif gpg_cmd == "import-key" then
            local key_file = args.query
            if not key_file then
                print("Error: key file path required")
                print("Usage: pkglet G import-key /path/to/key.pub")
            else
                gpg.import_key(key_file)
            end
            
        elseif gpg_cmd == "import-key-server" then
            local key_id = args.query
            if not key_id then
                print("Error: key ID required")
                print("Usage: pkglet G import-key-server KEYID")
            else
                gpg.import_key(key_id, true)
            end
            
        elseif gpg_cmd == "generate-key" then
            local name = args.query
            local email = args.target_version
            
            if not name or not email then
                print("Error: name and email required")
                print("Usage: pkglet G generate-key \"Name\" email@example.com")
            else
                io.write("Enter passphrase (optional, press Enter for none): ")
                local passphrase = io.read()
                passphrase = passphrase:trim()
                gpg.generate_key(name, email, passphrase)
            end
            
        elseif gpg_cmd == "export-key" then
            local key_id = args.query
            if not key_id then
                print("Error: key ID required")
                print("Usage: pkglet G export-key KEYID")
            else
                local output_file = args.target_version or key_id .. ".pub"
                gpg.export_public_key(key_id, output_file)
            end
            
        elseif gpg_cmd == "sign-package" then
            local package_file = args.query
            local key_id = args.target_version
            
            if not package_file then
                print("Error: package file path required")
                print("Usage: pkglet G sign-package package.tar.gz [key-id]")
            else
                gpg.sign_package(package_file, key_id)
            end
            
        elseif gpg_cmd == "verify-package" then
            local package_file = args.query
            local sig_file = args.target_version
            
            if not package_file then
                print("Error: package file path required")
                print("Usage: pkglet G verify-package package.tar.gz.asc [signature-file]")
            else
                local result = gpg.verify_package(package_file, sig_file)
                
                if result.status == "valid" then
                    print("✓ Valid signature from key " .. (result.key_id or "unknown"))
                    print("  Trust level: " .. (result.key_trusted and "trusted" or "untrusted"))
                elseif result.status == "invalid" then
                    print("✗ Invalid signature from key " .. (result.key_id or "unknown"))
                elseif result.status == "no_key" then
                    print("⚠ No public key found for signature (key ID: " .. (result.key_id or "unknown") .. ")")
                else
                    print("✗ Verification error: " .. (result.error or result.status))
                end
            end
            
        elseif gpg_cmd == "delete-key" then
            local key_id = args.query
            if not key_id then
                print("Error: key ID required")
                print("Usage: pkglet G delete-key KEYID")
            else
                io.write("Delete secret key too? [y/N]: ")
                local delete_secret = io.read()
                local delete_secret_bool = delete_secret:lower():sub(1,1) == 'y'
                gpg.delete_key(key_id, delete_secret_bool)
            end
            
        else
            print("Available GPG commands:")
            print("  list-keys                          - List all keys")
            print("  import-key <file>                   - Import public key from file")
            print("  import-key-server <key-id>           - Import key from server")
            print("  generate-key <name> <email>         - Generate new key pair")
            print("  export-key <key-id> [output-file]    - Export public key")
            print("  sign-package <package> [key-id]      - Sign package file")
            print("  verify-package <package> [sig-file]  - Verify package signature")
            print("  delete-key <key-id>                  - Delete key")
        end

    elseif args.command == "I" or args.command == "info" then
        local manifest = loader.load_manifest(args.package)
        loader.print_info(manifest)

    elseif args.command == "R" or args.command == "reverse-deps" then
        local conflict = require("src.conflict")
        local reverse_deps = conflict.get_reverse_dependencies(args.package)
        
        if #reverse_deps == 0 then
            print("No packages depend on " .. args.package)
        else
            print("Packages that depend on " .. args.package .. ":")
            for _, dep_pkg in ipairs(reverse_deps) do
                local version = installer.get_installed_version(dep_pkg)
                print("  " .. dep_pkg .. " (" .. (version or "unknown") .. ")")
            end
        end

    elseif args.command == "c" or args.command == "clean" then
        os.execute("rm -rf " .. config.CACHE_PATH)

    else
        cli.print_help()
        os.exit(1)
    end
end

local status, err = pcall(main)
if not status then
    io.stderr:write("\27[1;32mpkglet\27[0m: \27[1;31merror\27[0m: " .. tostring(err) .. "\n")
    os.exit(1)
end
